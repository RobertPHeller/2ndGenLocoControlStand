// -!- c++ -!- //////////////////////////////////////////////////////////////
//
//  System        : 
//  Module        : 
//  Object Name   : $RCSfile$
//  Revision      : $Revision$
//  Date          : $Date$
//  Author        : $Author$
//  Created By    : Robert Heller
//  Created       : Thu Oct 10 13:49:59 2019
//  Last Modified : <191010.1612>
//
//  Description	
//
//  Notes
//
//  History
//	
/////////////////////////////////////////////////////////////////////////////
//
//    Copyright (C) 2019  Robert Heller D/B/A Deepwoods Software
//			51 Locke Hill Road
//			Wendell, MA 01379-9728
//
//    This program is free software; you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation; either version 2 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program; if not, write to the Free Software
//    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
//
// 
//
//////////////////////////////////////////////////////////////////////////////

#ifndef __SNIPCLIENT_HXX
#define __SNIPCLIENT_HXX

#include "executor/StateFlow.hxx"
#include "openlcb/Defs.hxx"
#include "openlcb/If.hxx"
#include "openlcb/SimpleNodeInfo.hxx"
#include "os/os.h"

/// State flow to request SNIP information from a remote node on the OpenLCB
/// network.
///
/// Usage:
/// 
/// Create a global or local instance of this flow. Call the @ref request()
/// function with the arguments, supplying as notifiable the calling flow or a
/// sync notifiable for blocking operation on a thread. Wait for the
/// notification. Check that @ref error_code() == OPEATION_SUCCESS, then access
/// the returned protocol bitmask via the @ref response() accessor.

extern long long SNIP_CLIENT_TIMEOUT_NSEC;

class SNIPClient : public StateFlowBase
{
public:
    SNIPClient(openlcb::If *iface) : StateFlowBase(iface)
    {
    }
    
    /** Sends a SNIP request to the specified node.
     *
     * The current
     *
     * @param dst is the target node to query
     * @param src is the source node from which to send query
     * @param done will be notified if the request succeeds or fails or
     * timeouts)
     */
    void request(openlcb::NodeHandle dst, openlcb::Node *src, Notifiable *done)
    {
        src_ = src;
        dst_ = dst;
        done_ = done;
        errorCode_ = OPERATION_PENDING;
        snipResponse_.clear();
        start_flow(STATE(request_buffer));
    }

    /** @return the error code of the last request, or one of the internal
     * error codes from \ref SNIPClient::ResultCodes */
    uint32_t error_code()
    {
        return errorCode_;
    }

    /** Returns the response of the last request out, or unspecified if the
     * last request has not succeeded. */
    const openlcb::SnipDecodedData* response()
    {
        return &snipResponse_;
    }

    enum ResultCodes
    {
        // Internal error codes generated by the send flow
        OPERATION_SUCCESS = 0x10000, //< set when the Datagram OK arrives
        OPERATION_PENDING = 0x20000, //< cleared when done is called.
        TIMEOUT = 0x80000,           //< Timeout waiting for ack/nack.

        IDLE = 0xFFFF0000, //< The current flow is not in use.

    };

private:
    enum
    {
        MTI_1a = openlcb::Defs::MTI_TERMINATE_DUE_TO_ERROR,
        MTI_1b = openlcb::Defs::MTI_OPTIONAL_INTERACTION_REJECTED,
        MASK_1 = ~(MTI_1a ^ MTI_1b),
        MTI_1 = MTI_1a,

        MTI_2 = openlcb::Defs::MTI_IDENT_INFO_REPLY,
        MASK_2 = openlcb::Defs::MTI_EXACT,
    };

    Action request_buffer()
    {
        return allocate_and_call(
            iface()->addressed_message_write_flow(), STATE(write_request));
    }

    Action write_request()
    {
        auto *b =
            get_allocation_result(iface()->addressed_message_write_flow());
        b->data()->reset(openlcb::Defs::MTI_IDENT_INFO_REQUEST, src_->node_id(),
            dst_, openlcb::EMPTY_PAYLOAD);

        iface()->dispatcher()->register_handler(
            &responseHandler_, MTI_1, MASK_1);
        iface()->dispatcher()->register_handler(
            &responseHandler_, MTI_2, MASK_2);

        iface()->addressed_message_write_flow()->send(b);

        return sleep_and_call(
            &timer_, SNIP_CLIENT_TIMEOUT_NSEC, STATE(response_came));
    }

    // Callback from the response handler.
    void handle_response(Buffer<openlcb::GenMessage> *message)
    {
        AutoReleaseBuffer<openlcb::GenMessage> rb(message);
        if (src_ != message->data()->dstNode ||
            !iface()->matching_node(dst_, message->data()->src))
        {
            // Not from the right place.
            return;
        }
        if (message->data()->mti == openlcb::Defs::MTI_OPTIONAL_INTERACTION_REJECTED ||
            message->data()->mti == openlcb::Defs::MTI_TERMINATE_DUE_TO_ERROR)
        {
            uint16_t mti, error_code;
            openlcb::buffer_to_error(
                message->data()->payload, &error_code, &mti, nullptr);
            if (mti && mti != openlcb::Defs::MTI_IDENT_INFO_REQUEST)
            {
                // Got error response for a different interaction. Ignore.
                return;
            }
            errorCode_ = error_code;
        }
        else if (message->data()->mti == openlcb::Defs::MTI_IDENT_INFO_REPLY)
        {
            openlcb::decode_snip_response(message->data()->payload,&snipResponse_);
            errorCode_ = OPERATION_SUCCESS;
        }
        else
        {
            // Dunno what this MTI is. Ignore.
            LOG(INFO, "Unexpected MTI for SNIP response handler: %04x",
                message->data()->mti);
            return;
        }

        // Wakes up parent flow.
        errorCode_ &= ~OPERATION_PENDING;
        timer_.trigger();
    }

    Action response_came()
    {
        if (errorCode_ & OPERATION_PENDING)
        {
            errorCode_ = TIMEOUT;
        }
        iface()->dispatcher()->unregister_handler_all(&responseHandler_);
        done_->notify();
        return exit();
    }

    /// Message handler for incoming SNIP responses. Gets registered in the
    /// input inteface's dispatcher and proxies an incoming SNIP response to
    /// wake up the parent flow.
    class SNIPResponseHandler : public openlcb::MessageHandler
    {
    public:
        SNIPResponseHandler(SNIPClient *parent)
            : parent_(parent)
        {
        }

        void send(Buffer<openlcb::GenMessage> *message, unsigned priority) OVERRIDE
        {
            parent_->handle_response(message);
        }

    private:
        SNIPClient *parent_;
    };

    openlcb::If *iface()
    {
        return static_cast<openlcb::If *>(service());
    }

    StateFlowTimer timer_{this};
    openlcb::Node *src_;
    Notifiable *done_;
    openlcb::NodeHandle dst_;
    openlcb::SnipDecodedData snipResponse_;
    uint32_t errorCode_{IDLE};
    SNIPResponseHandler responseHandler_{this};
};    

#endif // __SNIPCLIENT_HXX

